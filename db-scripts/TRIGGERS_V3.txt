-- HR

CREATE OR REPLACE FUNCTION human_resources.set_position_defaults()
RETURNS TRIGGER AS $$
BEGIN

    IF NEW.employment_type = 'Contractual' AND NEW.typical_duration_days IS NULL THEN
        NEW.typical_duration_days := 90; -- Default 3 months
    ELSIF NEW.employment_type = 'Seasonal' AND NEW.typical_duration_days IS NULL THEN
        NEW.typical_duration_days := 14; -- Default 2 weeks
    END IF;
    
    IF NEW.is_active IS NULL THEN
        NEW.is_active := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION human_resources.update_position_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_position_defaults
BEFORE INSERT OR UPDATE ON human_resources.positions
FOR EACH ROW EXECUTE FUNCTION human_resources.set_position_defaults();

CREATE TRIGGER trg_update_position_timestamp
BEFORE UPDATE ON human_resources.positions
FOR EACH ROW EXECUTE FUNCTION human_resources.update_position_timestamp();


CREATE OR REPLACE FUNCTION human_resources.set_supervisor_flag()
RETURNS TRIGGER AS $$
BEGIN
    NEW.is_supervisor := EXISTS (
        SELECT 1 FROM human_resources.department_superiors ds
        WHERE ds.dept_id = NEW.dept_id AND ds.position_id = NEW.position_id
    );
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_supervisor_flag
BEFORE INSERT OR UPDATE ON human_resources.employees
FOR EACH ROW EXECUTE FUNCTION human_resources.set_supervisor_flag();

CREATE OR REPLACE FUNCTION human_resources.validate_superior()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.reports_to IS NOT NULL THEN
        -- Check if the superior exists and is in the same department
        IF NOT EXISTS (
            SELECT 1 FROM human_resources.employees sup
            WHERE sup.employee_id = NEW.reports_to
            AND sup.dept_id = NEW.dept_id
            AND sup.is_supervisor = TRUE  -- Ensure they're marked as supervisor
        ) THEN
            RAISE EXCEPTION 'Invalid superior: Must be a supervisor in the same department';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_superior
BEFORE INSERT OR UPDATE ON human_resources.employees
FOR EACH ROW EXECUTE FUNCTION human_resources.validate_superior();

CREATE OR REPLACE FUNCTION human_resources.update_employee_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_employee_timestamp
BEFORE UPDATE ON human_resources.employees
FOR EACH ROW EXECUTE FUNCTION human_resources.update_employee_timestamp();

CREATE OR REPLACE FUNCTION human_resources.calculate_work_hours()
RETURNS TRIGGER AS $$
BEGIN
 NEW.work_hours := 
        CASE WHEN NEW.time_out IS NULL THEN NULL
        ELSE EXTRACT(EPOCH FROM (NEW.time_out - NEW.time_in))/3600 END;
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calculate_work_hours
BEFORE INSERT OR UPDATE ON human_resources.attendance_tracking
FOR EACH ROW EXECUTE FUNCTION human_resources.calculate_work_hours();

CREATE OR REPLACE FUNCTION human_resources.detect_attendance_status() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.time_in IS NULL THEN
        NEW.status := 'Absent';
    ELSIF NEW.time_in > '[expected_start_time]' THEN 
        NEW.status := 'Late';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION human_resources.validate_salary()
RETURNS TRIGGER AS $$
DECLARE
 emp_type TEXT;
BEGIN
    SELECT employment_type INTO emp_type 
    FROM human_resources.employees 
    WHERE employee_id = NEW.employee_id;
    
    NEW.salary_id := 'SAL-' || to_char(CURRENT_DATE, 'YYYYMM') || '-' || substr(md5(random()::text), 1, 6);
    
    IF emp_type = 'Regular' THEN
        IF NEW.base_salary IS NULL OR NEW.base_salary <= 0 THEN
            RAISE EXCEPTION 'Regular employees must have a positive base salary';
        END IF;

IF emp_type = 'Regular' AND (
    NEW.base_salary < (SELECT min_salary FROM human_resources.positions p 
                      JOIN human_resources.employees e ON p.position_id = e.position_id 
                      WHERE e.employee_id = NEW.employee_id)
    OR 
    NEW.base_salary > (SELECT max_salary FROM human_resources.positions p 
                      JOIN human_resources.employees e ON p.position_id = e.position_id 
                      WHERE e.employee_id = NEW.employee_id)
) THEN 
    RAISE EXCEPTION 'Base salary must be within positionâ€™s min/max range';
END IF;

        IF NEW.daily_rate IS NOT NULL OR NEW.contract_start_date IS NOT NULL OR NEW.contract_end_date IS NOT NULL THEN
            RAISE EXCEPTION 'Regular employees should not have daily rates or contract dates';
        END IF;
    ELSIF emp_type IN ('Contractual', 'Seasonal') THEN
        IF NEW.daily_rate IS NULL OR NEW.daily_rate <= 0 THEN
            RAISE EXCEPTION 'Contractual/Seasonal employees must have a positive daily rate';
        END IF;
        IF NEW.contract_start_date IS NULL OR NEW.contract_end_date IS NULL OR NEW.contract_end_date <= NEW.contract_start_date THEN
            RAISE EXCEPTION 'Contractual/Seasonal employees require valid contract dates';
        END IF;
        IF NEW.base_salary IS NOT NULL THEN
            RAISE EXCEPTION 'Contractual/Seasonal employees should not have a base salary';
        END IF;
    END IF;
    
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_salary
BEFORE INSERT OR UPDATE ON human_resources.employee_salary
FOR EACH ROW EXECUTE FUNCTION human_resources.validate_salary();

CREATE OR REPLACE FUNCTION human_resources.calculate_performance_bonus()
RETURNS TRIGGER AS $$
BEGIN
    NEW.performance_id := 'HR-PERF-' || to_char(CURRENT_DATE, 'YYYY') || '-' || substr(md5(random()::text), 1, 6);

    SELECT 
        CASE 
            WHEN es.base_salary IS NOT NULL THEN 
                (es.base_salary * 12 * 
                    CASE 
                        WHEN NEW.rating = 5 THEN 0.10  
                        WHEN NEW.rating = 4 THEN 0.075   
                        WHEN NEW.rating = 3 THEN 0.05   
                        WHEN NEW.rating = 2 THEN 0.025   
                        ELSE 0.00
                    END)
            WHEN es.daily_rate IS NOT NULL THEN
                (es.daily_rate * 260 * 
                    CASE 
                        WHEN NEW.rating = 5 THEN 0.10  
                        WHEN NEW.rating = 4 THEN 0.075   
                        WHEN NEW.rating = 3 THEN 0.05   
                        WHEN NEW.rating = 2 THEN 0.025   
                        ELSE 0.00
                    END)
            ELSE 0
        END 
    INTO NEW.bonus_amount
    FROM human_resources.employee_salary es
    WHERE es.employee_id = NEW.employee_id
    ORDER BY es.effective_date DESC
    LIMIT 1;

    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calculate_performance_bonus
BEFORE INSERT OR UPDATE ON human_resources.employee_performance
FOR EACH ROW EXECUTE FUNCTION human_resources.calculate_performance_bonus();


CREATE OR REPLACE FUNCTION human_resources.track_allocation_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'Submitted' AND OLD.status != 'Submitted' THEN
        NEW.submitted_at = CURRENT_TIMESTAMP;
    ELSIF NEW.approval_status = 'Approved' AND OLD.approval_status != 'Approved' THEN
        NEW.approved_at = CURRENT_TIMESTAMP;
    END IF;
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_track_status
BEFORE UPDATE ON human_resources.workforce_allocation
FOR EACH ROW EXECUTE FUNCTION human_resources.track_allocation_status();

CREATE OR REPLACE FUNCTION check_assignment_overlap()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM human_resources.workforce_allocation
        WHERE employee_id = NEW.employee_id
        AND status = 'Active'
        AND (
            (start_date BETWEEN NEW.start_date AND NEW.end_date) OR
            (end_date BETWEEN NEW.start_date AND NEW.end_date) OR
            (NEW.start_date BETWEEN start_date AND end_date)
        )
    )THEN
        RAISE EXCEPTION 'Employee already has an active assignment during this period';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_assignment_overlap
BEFORE INSERT OR UPDATE ON human_resources.workforce_allocation
FOR EACH ROW EXECUTE FUNCTION check_assignment_overlap();


-- 1. Leave Request Processing
CREATE OR REPLACE FUNCTION human_resources.process_leave_request()
RETURNS TRIGGER AS $$
BEGIN
    NEW.leave_id := 'LV-' || to_char(CURRENT_DATE, 'YYYYMM') || '-' || substr(md5(random()::text), 1, 6);
    
    IF NOT EXISTS (
        SELECT 1 FROM human_resources.employees 
        WHERE employee_id = NEW.employee_id AND employment_type = 'Regular'
    ) THEN
        RAISE EXCEPTION 'Only regular employees can request leave';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Leave Approval Handling
CREATE OR REPLACE FUNCTION human_resources.handle_leave_approval()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    
    IF NEW.management_approval_id IS NOT NULL AND 
       (OLD.management_approval_id IS NULL OR OLD.management_approval_id != NEW.management_approval_id) THEN
        
        IF NOT EXISTS (
            SELECT 1 FROM management.approvals 
            WHERE approval_id = NEW.management_approval_id
        ) THEN
            RAISE EXCEPTION 'Invalid management approval reference: %', NEW.management_approval_id;
        END IF;
        
        SELECT 
            CASE WHEN status = 'Approved' THEN 'Approved by Management'
                 ELSE 'Rejected by Management' END
        INTO NEW.status
        FROM management.approvals
        WHERE approval_id = NEW.management_approval_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Leave Request Validation
CREATE OR REPLACE FUNCTION human_resources.validate_leave_request()
RETURNS TRIGGER AS $$
DECLARE
    current_balance RECORD;
    fiscal_year INT := EXTRACT(YEAR FROM CURRENT_DATE);
BEGIN
    SELECT * INTO current_balance
    FROM human_resources.employee_leave_balances
    WHERE employee_id = NEW.employee_id AND year = fiscal_year;
    
    IF NOT FOUND THEN
        INSERT INTO human_resources.employee_leave_balances (employee_id)
        VALUES (NEW.employee_id)
        RETURNING * INTO current_balance;
    END IF;
    
    CASE NEW.leave_type
        WHEN 'Sick' THEN
            IF NEW.total_days > current_balance.sick_leave_remaining THEN
                RAISE EXCEPTION 'Insufficient sick leave balance. Remaining: % days', current_balance.sick_leave_remaining;
            END IF;
        WHEN 'Vacation' THEN
            IF NEW.total_days > current_balance.vacation_leave_remaining THEN
                RAISE EXCEPTION 'Insufficient vacation leave balance. Remaining: % days', current_balance.vacation_leave_remaining;
            END IF;
        WHEN 'Maternity' THEN
            IF NEW.total_days > 105 THEN
                RAISE EXCEPTION 'Maternity leave cannot exceed 105 days';
            END IF;
            IF NEW.total_days > current_balance.maternity_leave_remaining THEN
                RAISE EXCEPTION 'Insufficient maternity leave balance. Remaining: % days', current_balance.maternity_leave_remaining;
            END IF;
        WHEN 'Paternity' THEN
            IF NEW.total_days > 7 THEN
                RAISE EXCEPTION 'Paternity leave cannot exceed 7 days';
            END IF;
            IF NEW.total_days > current_balance.paternity_leave_remaining THEN
                RAISE EXCEPTION 'Insufficient paternity leave balance. Remaining: % days', current_balance.paternity_leave_remaining;
            END IF;
        WHEN 'Solo Parent' THEN
            IF NEW.total_days > 7 THEN
                RAISE EXCEPTION 'Solo parent leave cannot exceed 7 days per year';
            END IF;
            IF NEW.total_days > current_balance.solo_parent_leave_remaining THEN
                RAISE EXCEPTION 'Insufficient solo parent leave balance. Remaining: % days', current_balance.solo_parent_leave_remaining;
            END IF;
        ELSE
            NULL;
    END CASE;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_process_leave_request
BEFORE INSERT ON human_resources.leave_requests
FOR EACH ROW EXECUTE FUNCTION human_resources.process_leave_request();

CREATE TRIGGER trg_validate_leave_request
BEFORE INSERT ON human_resources.leave_requests
FOR EACH ROW EXECUTE FUNCTION human_resources.validate_leave_request();

CREATE TRIGGER trg_handle_leave_approval
BEFORE UPDATE ON human_resources.leave_requests
FOR EACH ROW EXECUTE FUNCTION human_resources.handle_leave_approval();

CREATE OR REPLACE FUNCTION human_resources.generate_leave_balance_id()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.balance_id IS NULL THEN
        NEW.balance_id := 'LEAVE-BAL-' || NEW.employee_id || '-' || NEW.year;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_leave_balance_id
BEFORE INSERT ON human_resources.employee_leave_balances
FOR EACH ROW
EXECUTE FUNCTION human_resources.generate_leave_balance_id();


CREATE OR REPLACE FUNCTION human_resources.deduct_leave_balances()
RETURNS TRIGGER AS $$
BEGIN
    -- Only deduct when status changes to fully approved
    IF NEW.status = 'Approved by Management' AND OLD.status != 'Approved by Management' THEN
        UPDATE human_resources.employee_leave_balances
        SET
            sick_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Sick' THEN sick_leave_remaining - NEW.total_days 
                ELSE sick_leave_remaining END,
            vacation_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Vacation' THEN vacation_leave_remaining - NEW.total_days 
                ELSE vacation_leave_remaining END,
			maternity_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Maternity' THEN maternity_leave_remaining - NEW.total_days 
                ELSE maternity_leave_remaining END,
            paternity_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Paternity' THEN paternity_leave_remaining - NEW.total_days 
                ELSE paternity_leave_remaining END,
            solo_parent_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Solo Parent' THEN solo_parent_leave_remaining - NEW.total_days 
                ELSE solo_parent_leave_remaining END,
            unpaid_leave_taken = CASE 
                WHEN NEW.leave_type = 'Unpaid' THEN unpaid_leave_taken + NEW.total_days 
                ELSE unpaid_leave_taken END,
            updated_at = CURRENT_TIMESTAMP
        WHERE employee_id = NEW.employee_id
        AND year = EXTRACT(YEAR FROM NEW.start_date);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_deduct_leave_balances
AFTER UPDATE ON human_resources.leave_requests
FOR EACH ROW
EXECUTE FUNCTION human_resources.deduct_leave_balances();

CREATE OR REPLACE FUNCTION update_leave_balances()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'Approved by Management' AND OLD.status != 'Approved by Management' THEN
        UPDATE human_resources.employee_leave_balances
        SET 
            sick_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Sick' THEN GREATEST(0, sick_leave_remaining - NEW.total_days)
                ELSE sick_leave_remaining END,
            vacation_leave_remaining = CASE 
                WHEN NEW.leave_type = 'Vacation' THEN GREATEST(0, vacation_leave_remaining - NEW.total_days)
                ELSE vacation_leave_remaining END,
            unpaid_leave_taken = CASE
                WHEN NEW.is_paid = FALSE THEN unpaid_leave_taken + NEW.total_days
                ELSE unpaid_leave_taken END
        WHERE employee_id = NEW.employee_id AND year = EXTRACT(YEAR FROM NEW.start_date);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_leave_balances
AFTER UPDATE ON human_resources.leave_requests
FOR EACH ROW EXECUTE FUNCTION update_leave_balances();


CREATE OR REPLACE FUNCTION human_resources.set_compensation_values()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.position_id IS NOT NULL THEN
        IF NEW.employment_type = 'Regular' THEN
            SELECT min_salary INTO NEW.base_salary 
            FROM human_resources.positions 
            WHERE position_id = NEW.position_id;
        ELSIF NEW.employment_type IN ('Contractual', 'Seasonal') THEN
            SELECT min_salary/22 INTO NEW.daily_rate -- Convert monthly to daily rate
            FROM human_resources.positions
            WHERE position_id = NEW.position_id;
            
            IF NEW.duration_days IS NULL THEN
                SELECT typical_duration_days INTO NEW.duration_days
                FROM human_resources.positions
                WHERE position_id = NEW.position_id;
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION human_resources.validate_finance_approval()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.posting_status = 'Open' AND 
       (NEW.finance_approval_status != 'Approved' OR NEW.finance_approval_id IS NULL) THEN
        RAISE EXCEPTION 'Cannot open job posting without finance approval';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION human_resources.update_job_timestamps()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    
    IF NEW.finance_approval_id IS NOT NULL AND 
       (OLD.finance_approval_id IS DISTINCT FROM NEW.finance_approval_id) THEN
        IF NOT EXISTS (
            SELECT 1 FROM finance.budget_submission 
            WHERE submission_id = NEW.finance_approval_id
        ) THEN
            RAISE EXCEPTION 'Invalid finance approval reference: %', NEW.finance_approval_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_set_compensation
BEFORE INSERT OR UPDATE ON human_resources.job_posting
FOR EACH ROW EXECUTE FUNCTION human_resources.set_compensation_values();

CREATE TRIGGER trg_validate_approval
BEFORE INSERT OR UPDATE ON human_resources.job_posting
FOR EACH ROW EXECUTE FUNCTION human_resources.validate_finance_approval();

CREATE TRIGGER trg_update_timestamps
BEFORE UPDATE ON human_resources.job_posting
FOR EACH ROW EXECUTE FUNCTION human_resources.update_job_timestamps();
	
CREATE OR REPLACE FUNCTION human_resources.generate_bi_monthly_payroll()
RETURNS TRIGGER AS $$
DECLARE
    v_emp_data RECORD;
    v_attendance RECORD;
    v_calendar_data RECORD;
    v_performance_bonus DECIMAL(12,2) := 0;
    v_monthly_salary_equivalent DECIMAL(12,2);
    v_actual_work_days INT;
    v_daily_rate DECIMAL(12,2);
    v_base_pay DECIMAL(12,2);
    v_holiday_pay_calc DECIMAL(12,2) := 0;
    v_overtime_pay_calc DECIMAL(12,2) := 0;
    v_pay_period_days INT;
    v_expected_work_days INT;
    v_actual_attendance_days INT;
BEGIN
    -- 1. DATA VALIDATION
    IF NEW.employee_id IS NULL THEN
        RAISE EXCEPTION 'Employee ID cannot be null for payroll generation';
    END IF;

    IF NEW.pay_period_start IS NULL OR NEW.pay_period_end IS NULL THEN
        RAISE EXCEPTION 'Pay period dates must be specified';
    END IF;

    IF NEW.pay_period_end <= NEW.pay_period_start THEN
        RAISE EXCEPTION 'Pay period end date must be after start date';
    END IF;

    -- Get employee data with salary info
    SELECT 
        e.employment_type,
        es.base_salary,
        es.daily_rate,
        CASE 
            WHEN es.base_salary IS NOT NULL THEN es.base_salary / 2 
            ELSE es.daily_rate * 15 
        END AS semi_monthly_rate,
        CASE 
            WHEN es.base_salary IS NOT NULL THEN es.base_salary / (22 * 8) 
            ELSE es.daily_rate / 8 
        END AS hourly_rate,
        CASE 
            WHEN es.base_salary IS NOT NULL THEN es.base_salary 
            ELSE es.daily_rate * 22 
        END AS monthly_equivalent
    INTO v_emp_data
    FROM human_resources.employees e
    JOIN human_resources.employee_salary es ON e.employee_id = es.employee_id
    WHERE e.employee_id = NEW.employee_id
    ORDER BY es.effective_date DESC 
    LIMIT 1;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'No salary record found for employee %', NEW.employee_id;
    END IF;

    -- Calculate total days in pay period
    v_pay_period_days := NEW.pay_period_end - NEW.pay_period_start + 1;

    -- Get calendar data
    SELECT 
        COUNT(*) FILTER (WHERE is_holiday = TRUE AND is_special = FALSE) AS holidays,
        COUNT(*) FILTER (WHERE is_workday = TRUE) AS work_days,
        COUNT(*) AS total_days
    INTO v_calendar_data
    FROM human_resources.calendar_dates
    WHERE date BETWEEN NEW.pay_period_start AND NEW.pay_period_end;

    IF v_calendar_data.total_days < v_pay_period_days THEN
        RAISE EXCEPTION 'Missing calendar data for some days in pay period % to %', 
                        NEW.pay_period_start, NEW.pay_period_end;
    END IF;

    -- Get attendance data
    SELECT 
        COUNT(*) FILTER (WHERE status = 'Absent') AS absent_days,
        SUM(late_hours) AS total_late_hours,
        SUM(undertime_hours) AS total_undertime_hours,
        COUNT(*) FILTER (WHERE is_holiday = TRUE AND time_in IS NOT NULL) AS worked_holidays,
        SUM(CASE 
            WHEN status = 'Present' OR status = 'Late' THEN 
                CASE 
                    WHEN is_holiday THEN 1.3 
                    ELSE 1.0 
                END
            ELSE 0 
        END) AS effective_work_days,
        COUNT(*) AS recorded_days
    INTO v_attendance
    FROM human_resources.attendance_tracking
    WHERE employee_id = NEW.employee_id 
    AND date BETWEEN NEW.pay_period_start AND NEW.pay_period_end;

    IF v_attendance.recorded_days < v_calendar_data.work_days THEN
        RAISE WARNING 'Incomplete attendance records for employee % - only % of % work days recorded', 
                      NEW.employee_id, v_attendance.recorded_days, v_calendar_data.work_days;
    END IF;

    -- Compute base pay
    IF v_emp_data.employment_type = 'Regular' THEN
        v_base_pay := v_emp_data.semi_monthly_rate;
    ELSE
        v_actual_work_days := COALESCE(v_attendance.effective_work_days, 0);
        v_base_pay := v_emp_data.daily_rate * v_actual_work_days;
    END IF;

    -- Compute overtime
    v_overtime_pay_calc := NEW.overtime_hours * v_emp_data.hourly_rate * 1.5;

    -- Compute holiday pay
    IF v_emp_data.employment_type = 'Regular' THEN
        v_holiday_pay_calc := v_calendar_data.holidays * (v_emp_data.base_salary / 22);
        IF COALESCE(v_attendance.worked_holidays, 0) > 0 THEN
            v_holiday_pay_calc := v_holiday_pay_calc + 
                                  (v_attendance.worked_holidays * (v_emp_data.base_salary / 22) * 0.3);
        END IF;
    ELSE
        v_holiday_pay_calc := COALESCE(v_attendance.worked_holidays, 0) * v_emp_data.daily_rate * 1.3;
    END IF;

    -- Bonus pay for December
    IF EXTRACT(MONTH FROM NEW.pay_period_end) = 12 THEN
        SELECT bonus_amount INTO v_performance_bonus
        FROM human_resources.employee_performance
        WHERE employee_id = NEW.employee_id
        AND EXTRACT(YEAR FROM review_date) = EXTRACT(YEAR FROM NEW.pay_period_end)
        ORDER BY review_date DESC 
        LIMIT 1;
    END IF;

    -- Assign values
    NEW.base_salary := v_base_pay;
    NEW.overtime_pay := v_overtime_pay_calc;
    NEW.holiday_pay := v_holiday_pay_calc;
    NEW.bonus_pay := COALESCE(v_performance_bonus, 0);

    IF v_emp_data.employment_type = 'Regular' AND EXTRACT(MONTH FROM NEW.pay_period_end) = 12 THEN
        NEW.thirteenth_month_pay := v_emp_data.semi_monthly_rate;
    ELSE
        NEW.thirteenth_month_pay := 0;
    END IF;

    -- Contributions
    v_monthly_salary_equivalent := v_emp_data.monthly_equivalent;

    NEW.sss_contribution := human_resources.calculate_sss_contribution(NEW.employee_id, v_monthly_salary_equivalent);
    NEW.philhealth_contribution := LEAST(v_monthly_salary_equivalent * 0.02, 1800.00);
    NEW.pagibig_contribution := CASE 
        WHEN v_monthly_salary_equivalent <= 1500 THEN v_monthly_salary_equivalent * 0.01 
        ELSE LEAST(v_monthly_salary_equivalent * 0.02, 100.00) 
    END;

    -- Deductions
    NEW.late_deduction := COALESCE(v_attendance.total_late_hours, 0) * v_emp_data.hourly_rate;
    NEW.absent_deduction := COALESCE(v_attendance.absent_days, 0) * 
        CASE 
            WHEN v_emp_data.employment_type = 'Regular' THEN v_emp_data.base_salary / 22 
            ELSE v_emp_data.daily_rate 
        END;
    NEW.undertime_deduction := COALESCE(v_attendance.total_undertime_hours, 0) * v_emp_data.hourly_rate;

    -- Tax
    NEW.tax := human_resources.calculate_tax(
        NEW.base_salary + 
        NEW.overtime_pay + 
        NEW.holiday_pay + 
        NEW.bonus_pay + 
        NEW.thirteenth_month_pay
    );

    RETURN NEW;

EXCEPTION
    WHEN OTHERS THEN
        RAISE;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_generate_payroll
BEFORE INSERT ON human_resources.payroll
FOR EACH ROW EXECUTE FUNCTION human_resources.generate_bi_monthly_payroll();

CREATE OR REPLACE FUNCTION human_resources.calculate_tax(gross_pay DECIMAL)
RETURNS DECIMAL(12,2) AS $$
BEGIN	
 RETURN CASE
        WHEN gross_pay <= 20833 THEN 0
        WHEN gross_pay <= 33333 THEN (gross_pay - 20833) * 0.20
        WHEN gross_pay <= 66667 THEN 2500 + (gross_pay - 33333) * 0.25
        WHEN gross_pay <= 166667 THEN 10833 + (gross_pay - 66667) * 0.30
        WHEN gross_pay <= 666667 THEN 40833.33 + (gross_pay - 166667) * 0.32
        ELSE 200833.33 + (gross_pay - 666667) * 0.35
    END;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION human_resources.update_payroll_status()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;

    IF NEW.status = 'Processing' AND OLD.status != 'Processing' THEN
        NEW.status := 'Completed';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_payroll_status
BEFORE UPDATE ON human_resources.payroll
FOR EACH ROW EXECUTE FUNCTION human_resources.update_payroll_status();

-- Timestamp updates
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all tables with updated_at
CREATE TRIGGER trg_update_timestamp_employees
BEFORE UPDATE ON human_resources.employees
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_positions
BEFORE UPDATE ON human_resources.positions
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_workforce_allocation
BEFORE UPDATE ON human_resources.workforce_allocation
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_leave_requests
BEFORE UPDATE ON human_resources.leave_requests
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_job_posting
BEFORE UPDATE ON human_resources.job_posting
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_candidates
BEFORE UPDATE ON human_resources.candidates
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER trg_update_timestamp_payroll
BEFORE UPDATE ON human_resources.payroll
FOR EACH ROW EXECUTE FUNCTION update_timestamp();


CREATE OR REPLACE FUNCTION human_resources.generate_final_payroll()
RETURNS TRIGGER AS $$
DECLARE
    v_base_salary DECIMAL(12,2);
    v_final_payroll_id VARCHAR(255);
    v_employment_type VARCHAR(50);
BEGIN
    -- Generate payroll ID
    v_final_payroll_id := 'FPAY-' || NEW.employee_id || '-' || to_char(NEW.last_working_date, 'YYYYMMDD');

    -- Get current salary data
    SELECT 
        es.base_salary,
        es.employment_type
    INTO 
        v_base_salary,
        v_employment_type
    FROM human_resources.employee_salary es
    WHERE es.employee_id = NEW.employee_id
    ORDER BY es.effective_date DESC
    LIMIT 1;

    -- Insert final payroll record
    INSERT INTO human_resources.payroll (
        payroll_id,
        employee_id,
        pay_period_start,
        pay_period_end,
        employment_type,
        base_salary,
        bonus_pay,
        status,
        is_final_settlement
    ) VALUES (
        v_final_payroll_id,
        NEW.employee_id,
        DATE_TRUNC('month', NEW.last_working_date),
        NEW.last_working_date,
        v_employment_type,
        v_base_salary,
        0,
        'Pending',
        TRUE
    );

    RETURN NULL; 
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION human_resources.calculate_sss_contribution(
    p_employee_id VARCHAR(255),
    p_base_amount DECIMAL(12,2)  -- Can be monthly salary or daily rate
) RETURNS DECIMAL(12,2) AS $$
DECLARE
    v_employment_type VARCHAR(20);
    v_monthly_salary DECIMAL(12,2);
    v_sss_contribution DECIMAL(12,2);
BEGIN
    -- Get employment type
    SELECT employment_type INTO v_employment_type
    FROM human_resources.employees
    WHERE employee_id = p_employee_id;
    
    -- Convert daily rate to monthly equivalent if contractual/seasonal
    IF v_employment_type IN ('Contractual', 'Seasonal') THEN
        v_monthly_salary := p_base_amount * 22;  -- 22 working days/month
    ELSE
        v_monthly_salary := p_base_amount;
    END IF;
    
    v_sss_contribution := CASE
        WHEN v_monthly_salary < 3250 THEN 135.00
        WHEN v_monthly_salary BETWEEN 3250 AND 3750 THEN 157.50
        WHEN v_monthly_salary BETWEEN 3750 AND 4250 THEN 180.00
        WHEN v_monthly_salary BETWEEN 4250 AND 4750 THEN 202.50
        WHEN v_monthly_salary BETWEEN 4750 AND 5250 THEN 225.00
        WHEN v_monthly_salary BETWEEN 5250 AND 5750 THEN 247.50
        WHEN v_monthly_salary BETWEEN 5750 AND 6250 THEN 270.00
        WHEN v_monthly_salary BETWEEN 6250 AND 6750 THEN 292.50
        WHEN v_monthly_salary BETWEEN 6750 AND 7250 THEN 315.00
        WHEN v_monthly_salary BETWEEN 7250 AND 7750 THEN 337.50
        WHEN v_monthly_salary BETWEEN 7750 AND 8250 THEN 360.00
        WHEN v_monthly_salary BETWEEN 8250 AND 8750 THEN 382.50
        WHEN v_monthly_salary BETWEEN 8750 AND 9250 THEN 405.00
        WHEN v_monthly_salary BETWEEN 9250 AND 9750 THEN 427.50
        WHEN v_monthly_salary BETWEEN 9750 AND 10250 THEN 450.00
        WHEN v_monthly_salary BETWEEN 10250 AND 10750 THEN 472.50
        WHEN v_monthly_salary BETWEEN 10750 AND 11250 THEN 495.00
        WHEN v_monthly_salary BETWEEN 11250 AND 11750 THEN 517.50
        WHEN v_monthly_salary BETWEEN 11750 AND 12250 THEN 540.00
        WHEN v_monthly_salary BETWEEN 12250 AND 12750 THEN 562.50
        WHEN v_monthly_salary BETWEEN 12750 AND 13250 THEN 585.00
        WHEN v_monthly_salary BETWEEN 13250 AND 13750 THEN 607.50
        WHEN v_monthly_salary BETWEEN 13750 AND 14250 THEN 630.00
        WHEN v_monthly_salary BETWEEN 14250 AND 14750 THEN 652.50
        WHEN v_monthly_salary BETWEEN 14750 AND 15250 THEN 675.00
        WHEN v_monthly_salary BETWEEN 15250 AND 15750 THEN 697.50
        WHEN v_monthly_salary BETWEEN 15750 AND 16250 THEN 720.00
        WHEN v_monthly_salary BETWEEN 16250 AND 16750 THEN 742.50
        WHEN v_monthly_salary BETWEEN 16750 AND 17250 THEN 765.00
        WHEN v_monthly_salary BETWEEN 17250 AND 17750 THEN 787.50
        WHEN v_monthly_salary BETWEEN 17750 AND 18250 THEN 810.00
        WHEN v_monthly_salary BETWEEN 18250 AND 18750 THEN 832.50
        WHEN v_monthly_salary BETWEEN 18750 AND 19250 THEN 855.00
        WHEN v_monthly_salary BETWEEN 19250 AND 19750 THEN 877.50
        WHEN v_monthly_salary BETWEEN 19750 AND 20250 THEN 900.00
        WHEN v_monthly_salary BETWEEN 20250 AND 20750 THEN 922.50
        WHEN v_monthly_salary BETWEEN 20750 AND 21250 THEN 945.00
        WHEN v_monthly_salary BETWEEN 21250 AND 21750 THEN 967.50
        WHEN v_monthly_salary BETWEEN 21750 AND 22250 THEN 990.00
        WHEN v_monthly_salary BETWEEN 22250 AND 22750 THEN 1012.50
        WHEN v_monthly_salary BETWEEN 22750 AND 23250 THEN 1035.00
        WHEN v_monthly_salary BETWEEN 23250 AND 23750 THEN 1057.50
        WHEN v_monthly_salary BETWEEN 23750 AND 24250 THEN 1080.00
        WHEN v_monthly_salary BETWEEN 24250 AND 24750 THEN 1102.50
        WHEN v_monthly_salary >= 24750 THEN 1125.00
        ELSE 0.00
    END;
    
    RETURN v_sss_contribution;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION human_resources.generate_resignation_id()
RETURNS TRIGGER AS $$
DECLARE
    rand_text TEXT;
BEGIN
    rand_text := substring(md5(random()::text) from 1 for 5);

    NEW.resignation_id := 'RES-' || to_char(CURRENT_DATE, 'YYYYMMDD') || '-' || upper(rand_text);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_resignation_id
BEFORE INSERT ON human_resources.resignations
FOR EACH ROW
WHEN (NEW.resignation_id IS NULL)
EXECUTE FUNCTION human_resources.generate_resignation_id();

CREATE OR REPLACE FUNCTION human_resources.update_employee_resignation()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.approval_status = 'Approved' AND OLD.approval_status != 'Approved' THEN
        UPDATE human_resources.employees
        SET 
            status = CASE 
                WHEN CURRENT_DATE < NEW.last_working_date THEN 'On Notice'
                ELSE 'Resigned' END,
            resignation_date = NEW.submission_date,
            last_working_date = NEW.last_working_date
        WHERE employee_id = NEW.employee_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_employee_resignation
AFTER UPDATE ON human_resources.resignations
FOR EACH ROW EXECUTE FUNCTION human_resources.update_employee_resignation();

-- SALES
-- Trigger: Automatically create a Business Partner when a new customer is added
CREATE OR REPLACE FUNCTION sales.create_business_partner()
RETURNS TRIGGER AS $$
DECLARE
    new_partner_id VARCHAR(255);
BEGIN
    INSERT INTO admin.business_partner_master (customer_id, partner_name, category, contact_info)
    VALUES (NEW.customer_id, NEW.name, 'Customer', NEW.phone_number)
    RETURNING partner_id INTO new_partner_id;
	
    UPDATE sales.customers SET partner_id = new_partner_id
    WHERE  customer_id = NEW.customer_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_create_business_partner
AFTER INSERT ON sales.customers
FOR EACH ROW
EXECUTE FUNCTION sales.create_business_partner();

-- Trigger: Automatically create a GL Account when a new customer is added
CREATE OR REPLACE FUNCTION sales.create_gl_account()
RETURNS TRIGGER AS $$
DECLARE
    new_gl_account_id VARCHAR (255);
BEGIN
    INSERT INTO accounting.general_ledger_accounts (account_id, account_name, account_code, status)
    VALUES (NEW.customer_id, NEW.name,'ACC-COA-2025-CA1030','Active')
    RETURNING gl_account_id INTO new_gl_account_id;
    
    UPDATE sales.customers SET gl_account_id = new_gl_account_id WHERE customer_id = NEW.customer_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_create_gl_account
AFTER INSERT ON sales.customers
FOR EACH ROW
EXECUTE FUNCTION sales.create_gl_account();

-- Trigger: Creation of invoice after delivery confirmation
CREATE OR REPLACE FUNCTION sales.generate_invoice()
RETURNS TRIGGER AS $$
DECLARE 
  amount DECIMAL(10, 2);
BEGIN 
    SELECT total_amount INTO amount FROM sales.statement WHERE statement_id = NEW.statement_id;
    INSERT INTO sales.sales_invoices(delivery_note_id, total_amount)
    VALUES (NEW.delivery_note_id, amount);

    UPDATE sales.statement_item si_order
		SET quantity_to_deliver = quantity_to_deliver + delivery_data.quantity
		FROM (
		    SELECT o.statement_id AS order_statement_id, 
		           si_delivery.product_id, 
		           si_delivery.quantity,
                   d.delivery_note_id
		    FROM sales.delivery_note d
		    JOIN sales.orders o ON d.order_id = o.order_id
		    JOIN sales.statement s_order ON o.statement_id = s_order.statement_id
		    JOIN sales.statement s_delivery ON d.statement_id = s_delivery.statement_id
		    JOIN sales.statement_item si_delivery 
		        ON s_delivery.statement_id = si_delivery.statement_id WHERE d.order_id = NEW.order_id
		) AS delivery_data
		WHERE si_order.statement_id = delivery_data.order_statement_id
		AND si_order.product_id = delivery_data.product_id AND delivery_data.delivery_note_id = NEW.delivery_note_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_sales_invoice
AFTER INSERT ON sales.delivery_note
FOR EACH ROW
EXECUTE FUNCTION sales.generate_invoice();

-- Trigger: Insertion of order based on type
CREATE OR REPLACE FUNCTION insert_order_based_on_type()
RETURNS TRIGGER AS $$
DECLARE
    ext_id VARCHAR(255);
BEGIN
    -- Insert into the correct table based on quotation type
    IF NEW.order_type = 'Non-Project-Based'::order_type_enum THEN
        INSERT INTO mrp.non_project_order_pricing (order_id, final_price)
	VALUES (NEW.order_id, 0.00);
    
    ELSIF NEW.order_type = 'Project-Based'::order_type_enum THEN
        INSERT INTO project_management.external_project_request (ext_project_request_id, ext_project_name, ext_project_description, approval_id, item_id)
        VALUES (NEW.order_id, 'Project for Order ' || NEW.order_id, 'Automatically generated project request', NULL, NEW.order_id) RETURNING ext_project_request_id INTO ext_id;

        UPDATE sales.orders SET ext_project_request_id = ext_id WHERE order_id = NEW.order_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_insert_order_based_on_type
AFTER INSERT ON sales.orders
FOR EACH ROW
EXECUTE FUNCTION insert_order_based_on_type();

-- Trigger: Update delivery info status
CREATE OR REPLACE FUNCTION sales.update_order_delivery()   
RETURNS TRIGGER AS $$
DECLARE 
   tracking_no VARCHAR(255);
   shipped_date TIMESTAMP;
   est_delivery TIMESTAMP;
   shipping_cost DECIMAL(10,2);
   status shipment_status_type;
   qty_delivered DECIMAL(10, 2);
BEGIN
   IF OLD.shipment_id IS NULL AND NEW.shipment_id is NOT NULL THEN 
       SELECT sd.tracking_number, sd.shipment_date, sd.estimated_arrival_date, sc.total_shipping_cost, sd.shipment_status INTO 
       tracking_no, shipped_date, est_delivery, shipping_cost, status
        FROM distribution.shipment_details sd 
        INNER JOIN distribution.shipping_cost sc ON sd.shipping_cost_id = sc.shipping_cost_id 
        WHERE sd.shipment_id = NEW.shipment_id;
       
       UPDATE sales.delivery_note SET 
	   shipment_status = status, 
	   tracking_num = tracking_no, 
	   shipping_date = shipped_date, 
	   estimated_delivery = est_delivery 
        WHERE delivery_note_id = NEW.delivery_note_id;
       
       UPDATE sales.sales_invoices SET total_amount = COALESCE(total_amount, 0) + shipping_cost 
        WHERE delivery_note_id = NEW.delivery_note_id;
   ELSIF OLD.shipment_status <> 'Delivered'::shipment_status_type AND NEW.shipment_status = 'Delivered'::shipment_status_type THEN 
   		UPDATE sales.statement_item si_order
		SET quantity_delivered = quantity_delivered + delivery_data.quantity
		FROM (
		    SELECT o.statement_id AS order_statement_id, 
		           si_delivery.product_id, 
		           si_delivery.quantity,
                   d.delivery_note_id
		    FROM sales.delivery_note d
		    JOIN sales.orders o ON d.order_id = o.order_id
		    JOIN sales.statement s_order ON o.statement_id = s_order.statement_id
		    JOIN sales.statement s_delivery ON d.statement_id = s_delivery.statement_id
		    JOIN sales.statement_item si_delivery 
		        ON s_delivery.statement_id = si_delivery.statement_id WHERE d.order_id = NEW.order_id
		) AS delivery_data
		WHERE si_order.statement_id = delivery_data.order_statement_id
		AND si_order.product_id = delivery_data.product_id AND delivery_data.delivery_note_id = NEW.delivery_note_id;
   END IF;
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_delivery
AFTER UPDATE ON sales.delivery_note
FOR EACH ROW
EXECUTE FUNCTION sales.update_order_delivery();

CREATE OR REPLACE FUNCTION sales.update_delivery_status()
RETURNS TRIGGER AS $$
BEGIN
    -- Update delivery_note when shipment details changes
    UPDATE sales.delivery_note
    SET shipment_status = NEW.shipment_status, 
	tracking_num = NEW.tracking_number, 
	shipping_date = NEW.shipment_date, 
	estimated_delivery = NEW.estimated_arrival_date, 
	actual_delivery_date = NEW.actual_arrival_date
    WHERE shipment_id = NEW.shipment_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER shipment_status_update
AFTER UPDATE OF shipment_status ON distribution.shipment_details
FOR EACH ROW
WHEN (OLD.shipment_status IS DISTINCT FROM NEW.shipment_status)
EXECUTE FUNCTION sales.update_delivery_status();

-- Trigger: Calculate markup price
CREATE OR REPLACE FUNCTION calculate_product_pricing()
RETURNS TRIGGER AS $$
DECLARE
    base_price DECIMAL(10, 2); 
BEGIN
    -- Retrieve the quotation type directly
    SELECT selling_price INTO base_price FROM admin.products WHERE product_id = NEW.admin_product_id;
    NEW.selling_price := ROUND(base_price * (1 + (NEW.markup_percentage / 100)), 2);
    IF TG_OP = 'UPDATE' AND NEW.demand_level <> OLD.demand_level THEN
        NEW.markup_percentage := CASE
        WHEN NEW.demand_level = 'Very High'::demand_level_enum THEN 100.00
        WHEN NEW.demand_level = 'High'::demand_level_enum THEN 80.00
        WHEN NEW.demand_level = 'Medium'::demand_level_enum THEN 60.00
        WHEN NEW.demand_level = 'Low'::demand_level_enum THEN 20.00
        ELSE 20.00
        END;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calculate_product_pricing
BEFORE INSERT OR UPDATE ON sales.product_pricing
FOR EACH ROW
EXECUTE FUNCTION calculate_product_pricing();

-- Trigger: Determine Demand Level for Statement Items
CREATE OR REPLACE FUNCTION update_demand_level()
RETURNS TRIGGER AS $$
BEGIN
    -- Compute total quantity sold per product and rank using NTILE
    WITH demand_ranking AS (
        SELECT product_id,
               SUM(quantity) AS total_quantity,
               NTILE(10) OVER (ORDER BY SUM(quantity) DESC) AS demand_rank
        FROM sales.statement_item
        GROUP BY product_id
    ),
    recent_sales AS (
        SELECT product_id,
               SUM(quantity) AS recent_quantity
        FROM sales.statement_item
        WHERE created_at >= NOW() - INTERVAL '60 days'
        GROUP BY product_id
    ),
    total_sales AS (
        SELECT product_id, SUM(quantity) AS total_quantity
        FROM sales.statement_item
        GROUP BY product_id
    )
    UPDATE sales.product_pricing pp
    SET demand_level = CASE
        WHEN dr.demand_rank <= 1 THEN 'Very High'::demand_level_enum
        WHEN dr.demand_rank <= 3 THEN 'High'::demand_level_enum
        WHEN dr.demand_rank BETWEEN 4 AND 7 THEN 'Medium'::demand_level_enum
        WHEN dr.demand_rank BETWEEN 8 AND 10 THEN 'Low'::demand_level_enum
        WHEN rs.recent_quantity >= 0.9 * ts.total_quantity THEN 'Seasonal'::demand_level_enum
    END
    FROM demand_ranking dr
    LEFT JOIN recent_sales rs ON dr.product_id = rs.product_id
    LEFT JOIN total_sales ts ON dr.product_id = ts.product_id
    WHERE pp.admin_product_id = dr.product_id;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_demand_level
AFTER INSERT OR UPDATE OR DELETE ON sales.statement_item
FOR EACH ROW
EXECUTE FUNCTION update_demand_level();

CREATE OR REPLACE FUNCTION create_product_pricing()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO sales.product_pricing (admin_product_id) VALUES (NEW.product_id);
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_product_pricing
AFTER INSERT ON admin.products
FOR EACH ROW
EXECUTE FUNCTION create_product_pricing();

-- OPERATIONS
--auto generated serial and batch no
CREATE SEQUENCE operations.asset_serial_seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE FUNCTION operations.generate_asset_serial()
RETURNS TRIGGER AS $$
BEGIN

    NEW.serial_no := 'KNTP' || LPAD(nextval('operations.asset_serial_seq')::TEXT, 4, '0');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_asset_serial
BEFORE INSERT ON operations.serial_tracking
FOR EACH ROW
WHEN (NEW.serial_no IS NULL)
EXECUTE FUNCTION operations.generate_asset_serial();


CREATE SEQUENCE operations.batch_number_seq
START WITH 1
INCREMENT BY 1
NO CYCLE;

CREATE OR REPLACE FUNCTION operations.generate_batch_number()
RETURNS TRIGGER AS $$
DECLARE
    batch_date TEXT;
    batch_count TEXT;
BEGIN
    -- Generate batch number
    batch_date := to_char(CURRENT_DATE, 'YYYYMMDD');
    batch_count := LPAD(nextval('operations.batch_number_seq')::TEXT, 4, '0');
    NEW.batch_no := 'BN' || batch_date || '-' || batch_count;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_batch_number
BEFORE INSERT ON operations.document_items
FOR EACH ROW
WHEN (NEW.batch_no IS NULL)
EXECUTE FUNCTION operations.generate_batch_number();

UPDATE operations.serial_tracking
SET serial_no = 'KNTP' || LPAD(nextval('operations.asset_serial_seq')::TEXT, 4, '0')
WHERE serial_no IS NULL;

UPDATE operations.document_items
SET batch_no = 'BN' || to_char(CURRENT_DATE, 'YYYYMMDD') || '-' || LPAD(nextval('operations.batch_number_seq')::TEXT, 4, '0')
WHERE batch_no IS NULL;


-- Auto-generated A/R Credit Memo ID
CREATE SEQUENCE operations.ar_credit_memo_seq
START WITH 1
INCREMENT BY 1;

CREATE OR REPLACE FUNCTION operations.generate_ar_credit_memo_id()
RETURNS TRIGGER AS $$
DECLARE
    memo_date TEXT;
    memo_count TEXT;
BEGIN
    memo_date := to_char(CURRENT_DATE, 'YYYYMMDD');
    memo_count := LPAD(nextval('operations.ar_credit_memo_seq')::TEXT, 4, '0');
    NEW.ar_credit_memo := 'ARC' || memo_date || '-' || memo_count;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_generate_ar_credit_memo_id
BEFORE INSERT ON operations.document_header
FOR EACH ROW
WHEN (NEW.ar_credit_memo IS NULL)
EXECUTE FUNCTION operations.generate_ar_credit_memo_id();



CREATE OR REPLACE FUNCTION operations.handle_external_module_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert a new row into document_items with only external_id
    INSERT INTO operations.document_items (external_id)
    VALUES (NEW.external_id)
    ON CONFLICT (external_id) DO NOTHING; -- Avoid duplicate inserts

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_external_module_update
AFTER UPDATE ON operations.external_module
FOR EACH ROW
WHEN (OLD.external_id IS DISTINCT FROM NEW.external_id) -- Ensures update is relevant
EXECUTE FUNCTION operations.handle_external_module_update();


-- ADMIN

CREATE OR REPLACE FUNCTION admin.sync_item_master_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert into item_master_data based on the source table
    IF TG_TABLE_NAME = 'assets' THEN
        INSERT INTO admin.item_master_data (asset_id, item_type, item_name, manage_item_by)
        VALUES (NEW.asset_id, 'Asset', NEW.asset_name, 'Serial Number');

    ELSIF TG_TABLE_NAME = 'products' THEN
        INSERT INTO admin.item_master_data (product_id, item_type, item_name, unit_of_measure, manage_item_by, item_status)
        VALUES (NEW.product_id, 'Product', NEW.product_name, NEW.unit_of_measure, 'Batches', NEW.item_status);

    ELSIF TG_TABLE_NAME = 'raw_materials' THEN
        INSERT INTO admin.item_master_data (material_id, item_type, item_name, unit_of_measure, manage_item_by, preferred_vendor, purchasing_uom)
        VALUES (NEW.material_id, 'Raw Material', NEW.material_name, NEW.unit_of_measure, 'None', NEW.vendor_code, NEW.unit_of_measure);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Trigger for Assets Table
CREATE TRIGGER trg_sync_item_master_data_assets
AFTER INSERT ON admin.assets
FOR EACH ROW
EXECUTE FUNCTION admin.sync_item_master_data();

-- Trigger for Products Table
CREATE TRIGGER trg_sync_item_master_data_products
AFTER INSERT ON admin.products
FOR EACH ROW
EXECUTE FUNCTION admin.sync_item_master_data();

-- Trigger for Raw Materials Table
CREATE TRIGGER trg_sync_item_master_data_raw_materials
AFTER INSERT ON admin.raw_materials
FOR EACH ROW
EXECUTE FUNCTION admin.sync_item_master_data();


-- for audit_logs in admin table (will automatically update if someone updates, inserts, and deletes from table.)
CREATE OR REPLACE FUNCTION admin.generic_audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    action_type TEXT;
BEGIN
    IF TG_OP = 'INSERT' THEN
        action_type := 'INSERT';
    ELSIF TG_OP = 'UPDATE' THEN
        action_type := 'UPDATE';
    ELSIF TG_OP = 'DELETE' THEN
        action_type := 'DELETE';
    ELSE
        action_type := 'UNKNOWN';
    END IF;

    INSERT INTO admin.audit_log (
        user_id,
        action,
        timestamp,
        ip_address
    ) VALUES (
        NULL,
        action_type || ' on table ' || TG_TABLE_NAME,
        NOW(),
        inet_client_addr()
    );

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_generic_roles_permission
AFTER INSERT OR UPDATE OR DELETE ON admin.roles_permission
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For business_partner_master table
CREATE TRIGGER audit_generic_business_partner_master
AFTER INSERT OR UPDATE OR DELETE ON admin.business_partner_master
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For users table
CREATE TRIGGER audit_generic_users
AFTER INSERT OR UPDATE OR DELETE ON admin.users
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For vendor table
CREATE TRIGGER audit_generic_vendor
AFTER INSERT OR UPDATE OR DELETE ON admin.vendor
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For warehouse table
CREATE TRIGGER audit_generic_warehouse
AFTER INSERT OR UPDATE OR DELETE ON admin.warehouse
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For item_master_data table
CREATE TRIGGER audit_generic_item_master_data
AFTER INSERT OR UPDATE OR DELETE ON admin.item_master_data
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For assets table
CREATE TRIGGER audit_generic_assets
AFTER INSERT OR UPDATE OR DELETE ON admin.assets
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For raw_materials table
CREATE TRIGGER audit_generic_raw_materials
AFTER INSERT OR UPDATE OR DELETE ON admin.raw_materials
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For policies table
CREATE TRIGGER audit_generic_policies
AFTER INSERT OR UPDATE OR DELETE ON admin.policies
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For products table
CREATE TRIGGER audit_generic_products
AFTER INSERT OR UPDATE OR DELETE ON admin.products
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For currency table
CREATE TRIGGER audit_generic_currency
AFTER INSERT OR UPDATE OR DELETE ON admin.currency
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- For notifs table
CREATE TRIGGER audit_generic_notifications
AFTER INSERT OR UPDATE OR DELETE ON admin.notifications
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--PM TABLES
CREATE TRIGGER audit_generic_external_project_request
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_request
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_details
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_details
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_labor
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_labor
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_task_list
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_task_list
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_warranty
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_warranty
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_tracking
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_tracking
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_cost_management
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_cost_management
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_request
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_request
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_details
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_details
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_tracking
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_tracking
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_labor
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_labor
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_task_list
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_task_list
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_report_monitoring
AFTER INSERT OR UPDATE OR DELETE ON project_management.report_monitoring
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_project_equipments
AFTER INSERT OR UPDATE OR DELETE ON project_management.external_project_equipments
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_internal_project_cost_management 
AFTER INSERT OR UPDATE OR DELETE ON project_management.internal_project_cost_management 
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--MRP TABLES
CREATE TRIGGER audit_generic_bill_of_materials
AFTER INSERT OR UPDATE OR DELETE ON mrp.bill_of_materials
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_non_project_order_pricing
AFTER INSERT OR UPDATE OR DELETE ON mrp.non_project_order_pricing
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_principal_items
AFTER INSERT OR UPDATE OR DELETE ON mrp.principal_items
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_product_mats
AFTER INSERT OR UPDATE OR DELETE ON mrp.product_mats
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_labor_cost
AFTER INSERT OR UPDATE OR DELETE ON mrp.labor_cost
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--PRODUCTION TABLES
CREATE TRIGGER audit_generic_labor
AFTER INSERT OR UPDATE OR DELETE ON production.labor
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_equipment
AFTER INSERT OR UPDATE OR DELETE ON production.equipment
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_production_orders_header
AFTER INSERT OR UPDATE OR DELETE ON production.production_orders_header
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_production_orders_details
AFTER INSERT OR UPDATE OR DELETE ON production.production_orders_details
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_project_equipment
AFTER INSERT OR UPDATE OR DELETE ON production.project_equipment
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_rework_cost
AFTER INSERT OR UPDATE OR DELETE ON production.rework_cost
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--HR TABLES
CREATE TRIGGER audit_generic_departments
AFTER INSERT OR UPDATE OR DELETE ON human_resources.departments
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_employees
AFTER INSERT OR UPDATE OR DELETE ON human_resources.employees
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_attendance_tracking
AFTER INSERT OR UPDATE OR DELETE ON human_resources.attendance_tracking
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_leave_requests
AFTER INSERT OR UPDATE OR DELETE ON human_resources.leave_requests
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_workforce_allocation
AFTER INSERT OR UPDATE OR DELETE ON human_resources.workforce_allocation
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_job_posting
AFTER INSERT OR UPDATE OR DELETE ON human_resources.job_posting
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_candidates
AFTER INSERT OR UPDATE OR DELETE ON human_resources.candidates
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_employee_salary
AFTER INSERT OR UPDATE OR DELETE ON human_resources.employee_salary
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_employee_performance
AFTER INSERT OR UPDATE OR DELETE ON human_resources.employee_performance
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_payroll
AFTER INSERT OR UPDATE OR DELETE ON human_resources.payroll
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_positions
AFTER INSERT OR UPDATE OR DELETE ON human_resources.positions
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_department_superiors 
AFTER INSERT OR UPDATE OR DELETE ON human_resources.department_superiors 
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_employee_leave_balances  
AFTER INSERT OR UPDATE OR DELETE ON human_resources.employee_leave_balances  
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_calendar_dates 
AFTER INSERT OR UPDATE OR DELETE ON human_resources.calendar_dates  
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_resignations  
AFTER INSERT OR UPDATE OR DELETE ON human_resources.resignations  
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--SALES TABLES
CREATE TRIGGER audit_generic_customers
AFTER INSERT OR UPDATE OR DELETE ON sales.customers
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_statement
AFTER INSERT OR UPDATE OR DELETE ON sales.statement
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_statement_item
AFTER INSERT OR UPDATE OR DELETE ON sales.statement_item
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_product_pricing
AFTER INSERT OR UPDATE OR DELETE ON sales.product_pricing
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_blanket_agreement
AFTER INSERT OR UPDATE OR DELETE ON sales.blanket_agreement
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_quotation
AFTER INSERT OR UPDATE OR DELETE ON sales.quotation
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_orders
AFTER INSERT OR UPDATE OR DELETE ON sales.orders
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_payments
AFTER INSERT OR UPDATE OR DELETE ON sales.payments
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_sales_invoices
AFTER INSERT OR UPDATE OR DELETE ON sales.sales_invoices
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_ticket
AFTER INSERT OR UPDATE OR DELETE ON sales.ticket
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_ticket_convo
AFTER INSERT OR UPDATE OR DELETE ON sales.ticket_convo
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_campaigns
AFTER INSERT OR UPDATE OR DELETE ON sales.campaigns
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_campaign_contacts
AFTER INSERT OR UPDATE OR DELETE ON sales.campaign_contacts
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_opportunities
AFTER INSERT OR UPDATE OR DELETE ON sales.opportunities
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_return
AFTER INSERT OR UPDATE OR DELETE ON sales.return
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--SERVICES TABLES
CREATE TRIGGER audit_generic_service_call
AFTER INSERT OR UPDATE OR DELETE ON services.service_call
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_request
AFTER INSERT OR UPDATE OR DELETE ON services.service_request
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_analysis
AFTER INSERT OR UPDATE OR DELETE ON services.service_analysis
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_after_analysis_sched
AFTER INSERT OR UPDATE OR DELETE ON services.after_analysis_sched
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_order
AFTER INSERT OR UPDATE OR DELETE ON services.service_order
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_order_item
AFTER INSERT OR UPDATE OR DELETE ON services.service_order_item
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_delivery_order
AFTER INSERT OR UPDATE OR DELETE ON services.delivery_order
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_billing
AFTER INSERT OR UPDATE OR DELETE ON services.service_billing
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_report
AFTER INSERT OR UPDATE OR DELETE ON services.service_report
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_service_contract
AFTER INSERT OR UPDATE OR DELETE ON services.service_contract
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_additional_service
AFTER INSERT OR UPDATE OR DELETE ON services.additional_service
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_additional_service_type
AFTER INSERT OR UPDATE OR DELETE ON services.additional_service_type
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--MANAGEMANET TABLES
CREATE TRIGGER audit_generic_management_approvals
AFTER INSERT OR UPDATE OR DELETE ON management.management_approvals
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--ACCOUNTING TABLES
CREATE TRIGGER audit_generic_chart_of_accounts
AFTER INSERT OR UPDATE OR DELETE ON accounting.chart_of_accounts
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_general_ledger_accounts
AFTER INSERT OR UPDATE OR DELETE ON accounting.general_ledger_accounts
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_journal_entries
AFTER INSERT OR UPDATE OR DELETE ON accounting.journal_entries
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_journal_entry_lines
AFTER INSERT OR UPDATE OR DELETE ON accounting.journal_entry_lines
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_official_receipts
AFTER INSERT OR UPDATE OR DELETE ON accounting.official_receipts
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_financial_report
AFTER INSERT OR UPDATE OR DELETE ON accounting.financial_report
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--FINANCE TABLES
CREATE TRIGGER audit_generic_budget_validations
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_validations
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_budget_approvals
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_approvals
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_budget_allocation
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_allocation
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_budget_submission
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_submission
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_budget_request_form
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_request_form
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_budget_returns_form
AFTER INSERT OR UPDATE OR DELETE ON finance.budget_returns_form
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--OPERATIONS TABLES
CREATE TRIGGER audit_generic_document_header
AFTER INSERT OR UPDATE OR DELETE ON operations.document_header
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_product_document_items
AFTER INSERT OR UPDATE OR DELETE ON operations.product_document_items
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_external_module
AFTER INSERT OR UPDATE OR DELETE ON operations.external_module
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_serial_tracking
AFTER INSERT OR UPDATE OR DELETE ON operations.serial_tracking
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_documen_items
AFTER INSERT OR UPDATE OR DELETE ON operations.document_items
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--PURCHASING TABLES
CREATE TRIGGER audit_generic_vendor_application
AFTER INSERT OR UPDATE OR DELETE ON purchasing.vendor_application
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_purchase_requests
AFTER INSERT OR UPDATE OR DELETE ON purchasing.purchase_requests
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_quotation_contents
AFTER INSERT OR UPDATE OR DELETE ON purchasing.quotation_contents
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_purchase_quotation
AFTER INSERT OR UPDATE OR DELETE ON purchasing.purchase_quotation
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_purchase_order
AFTER INSERT OR UPDATE OR DELETE ON purchasing.purchase_order
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_purchase_invoice
AFTER INSERT OR UPDATE OR DELETE ON purchasing.purchase_invoice
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_received_shipments
AFTER INSERT OR UPDATE OR DELETE ON purchasing.received_shipments
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_batch_inspection
AFTER INSERT OR UPDATE OR DELETE ON purchasing.batch_inspection
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_credit_memo
AFTER INSERT OR UPDATE OR DELETE ON purchasing.credit_memo
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--INVENTORY TABLES
CREATE TRIGGER audit_generic_inventory_item
AFTER INSERT OR UPDATE OR DELETE ON inventory.inventory_item
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_inventory_cyclic_counts
AFTER INSERT OR UPDATE OR DELETE ON inventory.inventory_cyclic_counts
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_inventory_adjustments
AFTER INSERT OR UPDATE OR DELETE ON inventory.inventory_adjustments
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_deprecation_report
AFTER INSERT OR UPDATE OR DELETE ON inventory.deprecation_report
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

--DISTRIBUTION TABLES
CREATE TRIGGER audit_generic_carrier
AFTER INSERT OR UPDATE OR DELETE ON distribution.carrier
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_delivery_order
AFTER INSERT OR UPDATE OR DELETE ON distribution.delivery_order
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_logistics_approval_request
AFTER INSERT OR UPDATE OR DELETE ON distribution.logistics_approval_request
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_picking_list
AFTER INSERT OR UPDATE OR DELETE ON distribution.picking_list
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_packing_cost
AFTER INSERT OR UPDATE OR DELETE ON distribution.packing_cost
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_packing_list
AFTER INSERT OR UPDATE OR DELETE ON distribution.packing_list
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_shipping_cost
AFTER INSERT OR UPDATE OR DELETE ON distribution.shipping_cost
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_operational_cost
AFTER INSERT OR UPDATE OR DELETE ON distribution.operational_cost
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_shipment_details
AFTER INSERT OR UPDATE OR DELETE ON distribution.shipment_details
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_failed_shipment
AFTER INSERT OR UPDATE OR DELETE ON distribution.failed_shipment
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_delivery_receipt
AFTER INSERT OR UPDATE OR DELETE ON distribution.delivery_receipt
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_rejection
AFTER INSERT OR UPDATE OR DELETE ON distribution.rejection
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_rework_order
AFTER INSERT OR UPDATE OR DELETE ON distribution.rework_order
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_billing_receipt
AFTER INSERT OR UPDATE OR DELETE ON distribution.billing_receipt
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_goods_issue
AFTER INSERT OR UPDATE OR DELETE ON distribution.goods_issue
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

CREATE TRIGGER audit_generic_warehouse_movement
AFTER INSERT OR UPDATE OR DELETE ON inventory.warehouse_movement
FOR EACH ROW
EXECUTE FUNCTION admin.generic_audit_trigger();

-- automatically add vendor to vendor table once vendor_application is marked as 'approved'
CREATE OR REPLACE FUNCTION purchasing.auto_insert_vendor()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'Approved' THEN
        -- Check if vendor already exists for this application_reference
        IF NOT EXISTS (SELECT 1 FROM admin.vendor WHERE application_reference = NEW.application_reference) THEN
            INSERT INTO admin.vendor (
                vendor_code,
                application_reference,
                vendor_name,
                contact_person,
                status
            ) VALUES (
                NULL,
                NEW.application_reference,
                NEW.company_name,
                NEW.contact_person,
                'Active'
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- For INSERT
CREATE TRIGGER trg_auto_insert_vendor_on_insert
AFTER INSERT ON purchasing.vendor_application
FOR EACH ROW
EXECUTE FUNCTION purchasing.auto_insert_vendor();

-- For UPDATE
CREATE TRIGGER trg_auto_insert_vendor_on_update
AFTER UPDATE ON purchasing.vendor_application
FOR EACH ROW
WHEN (OLD.status IS DISTINCT FROM NEW.status OR OLD.status IS NULL)
EXECUTE FUNCTION purchasing.auto_insert_vendor();

-- updating bpm when new customers, vendors, employees are added. 

CREATE OR REPLACE FUNCTION human_resources.sync_bpm_employee()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert if not exists
    INSERT INTO admin.business_partner_master (employee_id, partner_name, category, contact_info)
    VALUES (NEW.employee_id, NEW.first_name || ' ' || NEW.last_name, 'Employee', COALESCE(NEW.phone, 'N/A'))
    ON CONFLICT (employee_id) DO UPDATE
    SET
        partner_name = EXCLUDED.partner_name,
        contact_info = EXCLUDED.contact_info;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_bpm_employee
AFTER INSERT OR UPDATE ON human_resources.employees
FOR EACH ROW
EXECUTE FUNCTION human_resources.sync_bpm_employee();

CREATE OR REPLACE FUNCTION admin.sync_bpm_vendor()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO admin.business_partner_master (vendor_code, partner_name, category, contact_info)
    VALUES (NEW.vendor_code, NEW.vendor_name, 'Vendor', NEW.contact_person)
    ON CONFLICT (vendor_code) DO UPDATE
    SET
        partner_name = EXCLUDED.partner_name,
        contact_info = EXCLUDED.contact_info;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_bpm_vendor
AFTER INSERT OR UPDATE ON admin.vendor
FOR EACH ROW
EXECUTE FUNCTION admin.sync_bpm_vendor();


CREATE OR REPLACE FUNCTION sales.sync_bpm_customer()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO admin.business_partner_master (customer_id, partner_name, category, contact_info)
    VALUES (NEW.customer_id, NEW.name, 'Customer', NEW.phone_number)
    ON CONFLICT (customer_id) DO UPDATE
    SET
        partner_name = EXCLUDED.partner_name,
        contact_info = EXCLUDED.contact_info;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_bpm_customer
AFTER INSERT OR UPDATE ON sales.customers
FOR EACH ROW
EXECUTE FUNCTION sales.sync_bpm_customer();

-- automatically adds new user when new employee is added
CREATE OR REPLACE FUNCTION admin.sync_users_from_employees()
RETURNS TRIGGER AS $$
DECLARE
    current_year TEXT;
    generated_email TEXT;
    generated_password TEXT;
BEGIN
    current_year := EXTRACT(YEAR FROM NOW())::TEXT;

    generated_email := LOWER(REPLACE(NEW.first_name, ' ', '') || '.' || REPLACE(NEW.last_name, ' ', '') || '@kinetiq.ph');

    generated_password := LOWER(NEW.first_name || REPLACE(NEW.last_name, ' ', '') || TO_CHAR(CURRENT_DATE, 'YYYY'));

    INSERT INTO admin.users (
        user_id,
        employee_id,
        first_name,
        last_name,
        email,
        password,
        role_id,
        status,
        type,
        created_at,
        updated_at
    ) VALUES (
        NULL,
        NEW.employee_id,
        NEW.first_name,
        NEW.last_name,
        generated_email,
        generated_password,
        NULL,
        'Active',
        'Employee',
        NOW(),
        NOW()
    )
    ON CONFLICT (employee_id) DO UPDATE 
    SET 
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        email = EXCLUDED.email,
        password = EXCLUDED.password, 
        updated_at = NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_users_from_employees
AFTER INSERT OR UPDATE ON human_resources.employees
FOR EACH ROW
EXECUTE FUNCTION admin.sync_users_from_employees();

-- automatically attaches warranty policy to products
CREATE OR REPLACE FUNCTION admin.auto_set_policy_id()
RETURNS TRIGGER AS $$
DECLARE
    default_policy_id VARCHAR(255);
BEGIN
    SELECT policy_id INTO default_policy_id
    FROM admin.policies
    WHERE policy_name = 'Warranty Policy'; 

    IF NEW.policy_id IS NULL THEN
        NEW.policy_id := default_policy_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_auto_set_policy_id
BEFORE INSERT ON admin.products
FOR EACH ROW
EXECUTE FUNCTION admin.auto_set_policy_id();

--user id in audit_log, should be connected to backend for it to work

CREATE OR REPLACE FUNCTION admin.track_user_activity()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.user_id IS NULL THEN
        NEW.user_id := (SELECT current_setting('app.current_user', true));
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_track_user
BEFORE INSERT ON admin.audit_log
FOR EACH ROW
EXECUTE FUNCTION admin.track_user_activity();

-- for password hashing

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE FUNCTION admin.hash_user_passwords()
RETURNS VOID AS $$
BEGIN
    UPDATE admin.users
    SET password = crypt(password, gen_salt('bf'))
    WHERE password NOT LIKE '$2a$%';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION admin.before_insert_users()
RETURNS TRIGGER AS $$
BEGIN
    NEW.password := crypt(NEW.password, gen_salt('bf'));
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_hash_user_passwords
BEFORE INSERT ON admin.users
FOR EACH ROW
EXECUTE FUNCTION admin.before_insert_users();


-- SERVICES

CREATE OR REPLACE FUNCTION services.update_end_date_trigger()
RETURNS TRIGGER AS $$
BEGIN
    -- update renewal dates
    IF NEW.renewal_id IS NOT NULL THEN
        SELECT renewal_warranty_start, renewal_warranty_end
        INTO NEW.renewal_date, NEW.renewal_end_date
        FROM services.warranty_renewal
        WHERE renewal_id = NEW.renewal_id;
    END IF;

    -- update end_date only if renewal_end_date is provided
    IF NEW.renewal_end_date IS NOT NULL THEN
        NEW.end_date := NEW.renewal_end_date;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_end_date
BEFORE UPDATE ON services.service_contract
FOR EACH ROW
EXECUTE FUNCTION services.update_end_date_trigger();


CREATE OR REPLACE FUNCTION services.update_service_order_item_prices()
RETURNS TRIGGER AS $$
DECLARE
    principal_markup_price DECIMAL(10,2);
BEGIN

    IF NEW.principal_item_id IS NOT NULL THEN
        -- get mark_up_price from principal_items
        SELECT mark_up_price
        INTO principal_markup_price 
        FROM mrp.principal_items
        WHERE principal_item_id = NEW.principal_item_id;

        NEW.item_price := principal_markup_price;
        NEW.total_price := principal_markup_price * NEW.item_quantity;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trigger_update_prices
BEFORE INSERT OR UPDATE ON services.service_order_item
FOR EACH ROW
EXECUTE FUNCTION services.update_service_order_item_prices();


CREATE OR REPLACE FUNCTION services.update_service_billing()
RETURNS TRIGGER AS $$
DECLARE 
    v_order_total_price DECIMAL(10,2) := 0.00;
    v_labor_cost DECIMAL(10,2) := 0.00;
    v_total_operational_cost DECIMAL(10,2) := 0.00;
    v_renewal_fee DECIMAL(10,2) := 0.00;
BEGIN
    -- Get renewal_fee if renewal_id is present
    IF NEW.renewal_id IS NOT NULL THEN
        SELECT COALESCE(renewal_fee, 0.00)
        INTO v_renewal_fee 
        FROM services.warranty_renewal
        WHERE renewal_id = NEW.renewal_id;

        -- Set total_payable to renewal_fee only
        NEW.total_payable := v_renewal_fee;

        -- Optionally set service_billing_amount to 0 or renewal_fee depending on your business rule
        NEW.service_billing_amount := 0.00; -- or := v_renewal_fee;

        RETURN NEW;
    END IF;

    -- If not renewal, proceed with normal calculations

    IF NEW.service_order_id IS NOT NULL THEN
        SELECT COALESCE(order_total_price, 0.00)
        INTO v_order_total_price
        FROM services.service_order
        WHERE service_order_id = NEW.service_order_id;
    END IF;

    IF NEW.analysis_id IS NOT NULL THEN
        SELECT COALESCE(labor_cost, 0.00)
        INTO v_labor_cost
        FROM services.service_analysis
        WHERE analysis_id = NEW.analysis_id;
    END IF;

    IF NEW.operational_cost_id IS NOT NULL THEN
        SELECT COALESCE(total_operational_cost, 0.00)
        INTO v_total_operational_cost
        FROM distribution.operational_cost
        WHERE operational_cost_id = NEW.operational_cost_id;
    END IF;

    NEW.service_billing_amount := v_order_total_price + v_labor_cost;
    NEW.total_payable := NEW.service_billing_amount + v_total_operational_cost + COALESCE(NEW.outsource_fee, 0.00);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_service_billing
BEFORE INSERT OR UPDATE ON services.service_billing
FOR EACH ROW
EXECUTE FUNCTION services.update_service_billing();

CREATE OR REPLACE FUNCTION services.update_renewal_fee_and_end()
RETURNS TRIGGER AS $$
DECLARE
    v_selling_price DECIMAL(10,2);
BEGIN
    -- Get selling_price by joining through contract_id â†’ product_id
    SELECT p.selling_price
    INTO v_selling_price
    FROM services.service_contract sc
    JOIN admin.products p ON sc.product_id = p.product_id
    WHERE sc.contract_id = NEW.contract_id;

    -- Compute renewal_fee
    NEW.renewal_fee := (v_selling_price * 0.20) * NEW.duration;
-- set renewal_warranty_end
    NEW.renewal_warranty_end := NEW.renewal_warranty_start + make_interval(years => NEW.duration);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trigger_update_renewal_fee_and_end
BEFORE INSERT OR UPDATE ON services.warranty_renewal
FOR EACH ROW
EXECUTE FUNCTION services.update_renewal_fee_and_end();